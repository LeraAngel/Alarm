{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useInputFormat, useInputFormatter, useRangeChecker } from \"./dateUtils\";\nimport * as React from 'react';\nimport { getTranslation } from 'react-native-paper-dates';\nexport default function useDateInput(_ref) {\n  var locale = _ref.locale,\n      value = _ref.value,\n      validRange = _ref.validRange,\n      inputMode = _ref.inputMode,\n      onChange = _ref.onChange;\n\n  var _useRangeChecker = useRangeChecker(validRange),\n      isDisabled = _useRangeChecker.isDisabled,\n      isWithinValidRange = _useRangeChecker.isWithinValidRange,\n      validStart = _useRangeChecker.validStart,\n      validEnd = _useRangeChecker.validEnd;\n\n  var _React$useState = React.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      error = _React$useState2[0],\n      setError = _React$useState2[1];\n\n  var formatter = useInputFormatter({\n    locale: locale\n  });\n  var inputFormat = useInputFormat({\n    formatter: formatter,\n    locale: locale\n  });\n  var formattedValue = formatter.format(value);\n\n  var onChangeText = function onChangeText(date) {\n    var dayIndex = inputFormat.indexOf('DD');\n    var monthIndex = inputFormat.indexOf('MM');\n    var yearIndex = locale === 'pt' ? inputFormat.indexOf('AAAA') : inputFormat.indexOf('YYYY');\n    var day = Number(date.slice(dayIndex, dayIndex + 2));\n    var year = Number(date.slice(yearIndex, yearIndex + 4));\n    var month = Number(date.slice(monthIndex, monthIndex + 2));\n\n    if (Number.isNaN(day) || Number.isNaN(year) || Number.isNaN(month)) {\n      setError(getTranslation(locale, 'notAccordingToDateFormat', function () {\n        return 'notAccordingToDateFormat';\n      })(inputFormat));\n      return;\n    }\n\n    var finalDate = inputMode === 'end' ? new Date(year, month - 1, day, 23, 59, 59) : new Date(year, month - 1, day);\n\n    if (isDisabled(finalDate)) {\n      setError(getTranslation(locale, 'dateIsDisabled'));\n      return;\n    }\n\n    if (!isWithinValidRange(finalDate)) {\n      var errors = validStart && validEnd ? [\"\" + getTranslation(locale, 'mustBeBetween', function () {\n        return 'mustBeBetween';\n      })(formatter.format(validStart), formatter.format(validEnd))] : [validStart ? getTranslation(locale, 'mustBeHigherThan', function () {\n        return 'mustBeHigherThan';\n      })(formatter.format(validStart)) : '', validEnd ? getTranslation(locale, 'mustBeLowerThan', function () {\n        return 'mustBeLowerThan';\n      })(formatter.format(validEnd)) : ''];\n      setError(errors.filter(function (n) {\n        return n;\n      }).join(' '));\n      return;\n    }\n\n    setError(null);\n\n    if (inputMode === 'end') {\n      onChange(finalDate);\n    } else {\n      onChange(finalDate);\n    }\n  };\n\n  return {\n    onChange: onChange,\n    error: error,\n    formattedValue: formattedValue,\n    onChangeText: onChangeText,\n    inputFormat: inputFormat\n  };\n}","map":{"version":3,"sources":["inputUtils.ts"],"names":["onChange","validEnd","useRangeChecker","React","formatter","useInputFormatter","locale","inputFormat","useInputFormat","formattedValue","onChangeText","date","dayIndex","monthIndex","yearIndex","day","Number","year","month","setError","getTranslation","finalDate","inputMode","isDisabled","isWithinValidRange","errors","validStart","n","error"],"mappings":"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","sourcesContent":["import { useInputFormat, useInputFormatter, useRangeChecker } from './dateUtils'\nimport * as React from 'react'\nimport type { ValidRangeType } from './Calendar'\nimport { getTranslation } from 'react-native-paper-dates'\n\nexport default function useDateInput({\n  locale,\n  value,\n  validRange,\n  inputMode,\n  onChange,\n}: {\n  onChange: (d: Date) => void\n  locale: undefined | string\n  value: Date | undefined\n  validRange: ValidRangeType | undefined\n  inputMode: 'start' | 'end'\n}) {\n  const { isDisabled, isWithinValidRange, validStart, validEnd } =\n    useRangeChecker(validRange)\n  const [error, setError] = React.useState<null | string>(null)\n  const formatter = useInputFormatter({ locale })\n  const inputFormat = useInputFormat({ formatter, locale })\n  const formattedValue = formatter.format(value)\n  const onChangeText = (date: string) => {\n    const dayIndex = inputFormat.indexOf('DD')\n    const monthIndex = inputFormat.indexOf('MM')\n    const yearIndex =\n      locale === 'pt'\n        ? inputFormat.indexOf('AAAA')\n        : inputFormat.indexOf('YYYY')\n\n    const day = Number(date.slice(dayIndex, dayIndex + 2))\n    const year = Number(date.slice(yearIndex, yearIndex + 4))\n    const month = Number(date.slice(monthIndex, monthIndex + 2))\n\n    if (Number.isNaN(day) || Number.isNaN(year) || Number.isNaN(month)) {\n      setError(\n        getTranslation(\n          locale,\n          'notAccordingToDateFormat',\n          () => 'notAccordingToDateFormat'\n        )(inputFormat)\n      )\n      return\n    }\n\n    const finalDate =\n      inputMode === 'end'\n        ? new Date(year, month - 1, day, 23, 59, 59)\n        : new Date(year, month - 1, day)\n\n    if (isDisabled(finalDate)) {\n      setError(getTranslation(locale, 'dateIsDisabled'))\n      return\n    }\n    if (!isWithinValidRange(finalDate)) {\n      let errors =\n        validStart && validEnd\n          ? [\n              `${getTranslation(\n                locale,\n                'mustBeBetween',\n                () => 'mustBeBetween'\n              )(formatter.format(validStart), formatter.format(validEnd))}`,\n            ]\n          : [\n              validStart\n                ? getTranslation(\n                    locale,\n                    'mustBeHigherThan',\n                    () => 'mustBeHigherThan'\n                  )(formatter.format(validStart))\n                : '',\n              validEnd\n                ? getTranslation(\n                    locale,\n                    'mustBeLowerThan',\n                    () => 'mustBeLowerThan'\n                  )(formatter.format(validEnd))\n                : '',\n            ]\n      setError(errors.filter((n) => n).join(' '))\n      return\n    }\n\n    setError(null)\n    if (inputMode === 'end') {\n      onChange(finalDate)\n    } else {\n      onChange(finalDate)\n    }\n  }\n  return {\n    onChange,\n    error,\n    formattedValue,\n    onChangeText,\n    inputFormat,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}